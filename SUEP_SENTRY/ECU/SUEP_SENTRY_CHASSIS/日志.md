### 2025/07/03

**初步底盘代码撰写完成，进行测试**

- 进行一个`can1`占`FIFO0`，`can2`占`FIFO1`会出现只有`FIFO0`回传消息的问题,并且两个都占用`fifo0`时不使用`hcan`判断会导致只有`hcan1`会有数据，很奇怪，以下是有问题的代码

```
CAN_FilterTypeDef can_filter_st1;
//手册中的CAN2_SB = 28 时，可以使用CAN1的所有过滤器
//这里配置为can1:0-14 can2:14-28
can_filter_st1.SlaveStartFilterBank = 14;
can_filter_st1.FilterActivation = ENABLE;
can_filter_st1.FilterMode = CAN_FILTERMODE_IDMASK;
can_filter_st1.FilterScale = CAN_FILTERSCALE_32BIT;
can_filter_st1.FilterIdHigh = 0x0000;
can_filter_st1.FilterIdLow = 0x0000;
can_filter_st1.FilterMaskIdHigh = 0x0000;
can_filter_st1.FilterMaskIdLow = 0x0000;
can_filter_st1.FilterBank = 0;
//CAN1使用FIFO0
can_filter_st1.FilterFIFOAssignment = CAN_RX_FIFO0;
HAL_CAN_ConfigFilter(&hcan1, &can_filter_st1);
HAL_CAN_Start(&hcan1);
HAL_CAN_ActivateNotification(&hcan1, CAN_IT_RX_FIFO0_MSG_PENDING);

CAN_FilterTypeDef can_filter_st2;
//手册中的CAN2_SB = 28 时，可以使用CAN1的所有过滤器
//这里配置为can1:0-14 can2:14-28
// can_filter_st2.SlaveStartFilterBank = 14;
can_filter_st2.FilterActivation = ENABLE;
can_filter_st2.FilterMode = CAN_FILTERMODE_IDMASK;
can_filter_st2.FilterScale = CAN_FILTERSCALE_32BIT;
can_filter_st2.FilterIdHigh = 0x0000;
can_filter_st2.FilterIdLow = 0x0000;
can_filter_st2.FilterMaskIdHigh = 0x0000;
can_filter_st2.FilterMaskIdLow = 0x0000;
can_filter_st2.FilterBank = 14;
//CAN1使用FIFO1
can_filter_st2.FilterFIFOAssignment = CAN_RX_FIFO1;
HAL_CAN_ConfigFilter(&hcan2, &can_filter_st2);
HAL_CAN_Start(&hcan2);
HAL_CAN_ActivateNotification(&hcan2, CAN_IT_RX_FIFO1_MSG_PENDING);

```

- [x] 解决

- `cubemx`配置问题，一直理解的是`CAN1 RX0 interrupts`与`CAN1 RX1 interrupts`是引脚复用的不同`fifo`中断选项，实则是`fifo0`与`fifo1`的中断选项

- 通过观察`CAN_RF1R`接收`FIFO1`寄存器观察`FMP1`即`fifo`中的消息，是否大于0，判断是否接收到消息，再观察`CAN_IER`中的中断使能

- 而后又发现`can1`使用`fifo0`，`can2`使用`fifo1`会出现只有`fifo0`能使用，`can1`单独使用`fifo0`，`can2`单独使用`fifo1`都是可以的，`debug`的时候发现出问题的`can2 fifo1`中断使能了，但是没有`fifo1`上溢，两个过滤器都加上`can_filter_st2.SlaveStartFilterBank = 14;`就可以了

  
